import { jsPDF } from "jspdf";
import autoTable from "jspdf-autotable";
import {
  ZODIAC_SIGNS,
  SIGN_LORDS,
  PLANET_SYMBOLS,
  DASHA_ORDER_PAGE5,
  DASHA_ORDER_PAGE6,
  COLORS,
  Labels,
  ASCENDANT_DATA,
} from "./constants";
import {
  addPageBackground,
  addPageHeader,
  addSectionTitle,
  drawCornerDecoration,
  drawNorthIndianChart,
  drawDecoLine, // Now from helpers
  getDevanagariImage,
  getGaneshaImage,
  getLocalImageBase64,
} from "./helpers";

type Color3 = [number, number, number];

// ============================================================
// PAGE 1 — COVER PAGE
// ============================================================
export function renderCoverPage(
  doc: any,
  name: string,
  dob: string,
  tob: string,
  pob: string,
  lang: string,
  L: any,
) {
  const w = doc.internal.pageSize.getWidth();
  const h = doc.internal.pageSize.getHeight();

  // Cover page has unique design - keep custom background
  doc.setFillColor(255, 255, 255);
  doc.rect(0, 0, w, h, "F");

  // Subtle mandala/floral geometric background
  doc.setDrawColor(245, 245, 245);
  doc.setLineWidth(0.3);
  for (let x = 0; x <= w + 20; x += 30) {
    for (let y = 0; y <= h + 20; y += 30) {
      doc.circle(x, y, 10, "S");
      doc.circle(x, y, 15, "S");
      doc.circle(x, y, 22, "S");
    }
  }

  const cx = w / 2;

  // Ganesha Image — prefer real file, fall back to canvas drawing
  const ganeshaFileImg = getLocalImageBase64("ganesh.png");
  const ganeshaData = ganeshaFileImg || getGaneshaImage();
  const imgSize = 55;
  if (ganeshaFileImg) {
    doc.addImage(ganeshaFileImg, "PNG", cx - imgSize / 2, 25, imgSize, imgSize);
  } else if (ganeshaData) {
    doc.addImage(ganeshaData, "JPEG", cx - imgSize / 2, 25, imgSize, imgSize);
  }

  // Hindi Mantra
  const mantraY = 25 + imgSize + 5;
  const mantraText = "॥ श्री गणेशाय नमः ॥";
  const mantraImg = getDevanagariImage(mantraText, "#E33510");

  if (mantraImg) {
    const mH = 10;
    const mW = (mantraImg.w / mantraImg.h) * mH;
    doc.addImage(mantraImg.data, "JPEG", cx - mW / 2, mantraY, mW, mH);
  } else {
    doc.setFont("helvetica", "bold");
    doc.setFontSize(22);
    doc.setTextColor(227, 53, 16);
    doc.text("|| Shree Ganeshay Namah ||", cx, mantraY + 6, {
      align: "center",
    });
  }

  // Orange Center Band
  const bandY = 125;
  const bandH = 55;
  doc.setFillColor(232, 119, 0);
  doc.rect(0, bandY, w, bandH, "F");

  // Text inside band
  let textY = bandY + 16;
  doc.setFont("helvetica", "normal");
  doc.setFontSize(16);
  doc.setTextColor(255, 255, 255);
  doc.text(L.title || "HOROSCOPE FOR", cx, textY, { align: "center" });

  textY += 10;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(14);
  doc.text(String(name).toUpperCase(), cx, textY, { align: "center" });

  textY += 7;
  doc.setFontSize(9);
  doc.text(`${dob}    ${tob}`, cx, textY, { align: "center" });

  textY += 6;
  doc.text(String(pob), cx, textY, { align: "center" });

  // Footer Logo
  const footerY = h - 35;
  doc.setFont("helvetica", "normal");
  doc.setFontSize(9);
  doc.setTextColor(100, 100, 100);
  doc.text("generated by", cx, footerY, { align: "center" });

  const logoY = footerY + 8;
  doc.setFont("helvetica", "bold");
  doc.setFontSize(16);
  doc.setTextColor(219, 39, 119);
  doc.text("astrology", cx - 18, logoY, { align: "center" });
  doc.setTextColor(59, 130, 246);
  doc.text("API", cx + 22, logoY, { align: "center" });
}

// ============================================================
// PAGE 2 — BASIC ASTROLOGICAL DETAILS
// ============================================================
export function renderBasicDetailsPage(
  doc: any,
  name: string,
  dob: string,
  tob: string,
  pob: string,
  lat: number,
  lon: number,
  tz: number,
  apiData: Record<string, any>,
  L: any,
) {
  doc.addPage();
  const w = doc.internal.pageSize.getWidth();

  // ✅ USE MINI HELPERS
  addPageBackground(doc);
  let y = addPageHeader(doc, L.basicDetails || "Basic Astrological Details");

  const titleBlue: Color3 = [30, 50, 100];
  const orange: Color3 = [242, 114, 0];

  // Extract Data
  const bd = apiData?.birth_details || {};
  const ad = apiData?.astro_details || {};
  const gd = apiData?.ghat_chakra || {};

  // Table Styling
  const tableStyles = {
    theme: "plain" as const,
    styles: { cellPadding: 2.5, fontSize: 8, font: "helvetica" },
    bodyStyles: { textColor: [80, 80, 80] as Color3 },
    columnStyles: {
      0: {
        fontStyle: "bold" as const,
        cellWidth: 35,
        textColor: [50, 50, 50] as Color3,
      },
    },
    alternateRowStyles: { fillColor: [253, 238, 242] as Color3 },
    margin: { top: 0, bottom: 0 },
  };

  const margin = 14;
  const gap = 15;
  const colW = (w - margin * 2 - gap) / 2;
  const col1X = margin;
  const col2X = margin + colW + gap;

  // LEFT COLUMN: Basic Details
  y = addSectionTitle(doc, "Basic Details", y, { centerX: col1X + colW / 2 });

  const basicRows = [
    ["Date of birth", dob],
    ["Time of birth", tob],
    ["Place of birth", pob],
    ["Latitude", String(lat)],
    ["Longitude", String(lon)],
    ["Timezone", String(tz)],
    ["Ayanamsha", String(bd?.ayanamsha || "N/A")],
    ["Sunrise", bd?.sunrise || "—"],
    ["Sunset", bd?.sunset || "—"],
  ];

  // Orange border box
  doc.setDrawColor(orange[0], orange[1], orange[2]);
  doc.setLineWidth(0.3);
  doc.rect(col1X, y, colW, basicRows.length * 6.5);

  autoTable(doc, {
    ...tableStyles,
    startY: y,
    margin: { left: col1X + 1, right: colW + gap },
    tableWidth: colW - 2,
    body: basicRows,
  });

  // @ts-ignore
  let leftY = doc.lastAutoTable?.finalY + 15;

  // Ghat Chakra
  if (gd && Object.keys(gd).length > 0) {
    leftY = addSectionTitle(doc, "Ghat Chakra", leftY, {
      centerX: col1X + colW / 2,
    });

    const ghatRows: string[][] = [];
    Object.entries(gd).forEach(([key, value]) => {
      if (key !== "statusCode" && key !== "status") {
        ghatRows.push([
          key.charAt(0).toUpperCase() + key.slice(1),
          String(value),
        ]);
      }
    });

    autoTable(doc, {
      ...tableStyles,
      startY: leftY,
      margin: { left: col1X },
      tableWidth: colW,
      body: ghatRows,
    });
  }

  // RIGHT COLUMN: Panchang Details
  let rightY = y - 12; // Start at same level as left
  rightY = addSectionTitle(doc, "Panchang Details", rightY, {
    centerX: col2X + colW / 2,
  });

  const panchangRows = [
    ["Tithi", ad?.Tithi || "—"],
    ["Yog", ad?.Yog || "—"],
    ["Nakshatra", ad?.Naksahtra || "—"],
    ["Karan", ad?.Karan || "—"],
  ];

  autoTable(doc, {
    ...tableStyles,
    startY: rightY,
    margin: { left: col2X },
    tableWidth: colW,
    body: panchangRows,
  });

  // @ts-ignore
  rightY = doc.lastAutoTable?.finalY + 15;

  // Astrological Details
  rightY = addSectionTitle(doc, "Astrological Details", rightY, {
    centerX: col2X + colW / 2,
  });

  const astroRows = [
    ["Varna", ad?.Varna || "—"],
    ["Vashya", ad?.Vashya || "—"],
    ["Yoni", ad?.Yoni || "—"],
    ["Gan", ad?.Gan || "—"],
    ["Nadi", ad?.Nadi || "—"],
    ["Sign", ad?.sign || "—"],
    ["Sign Lord", ad?.SignLord || "—"],
    ["Nakshatra", ad?.Naksahtra || "—"],
    ["Nakshatra Lord", ad?.NaksahtraLord || "—"],
    ["Charan", String(ad?.Charan || "—")],
    ["Yunja", ad?.yunja || "—"],
    ["Tatva", ad?.tatva || "—"],
    ["Name Alphabet", ad?.name_alphabet || "—"],
    ["Paya", ad?.paya || "—"],
    ["Ascendant", ad?.ascendant || "—"],
    ["Ascendant Lord", ad?.ascendant_lord || "—"],
  ];

  autoTable(doc, {
    ...tableStyles,
    startY: rightY,
    margin: { left: col2X },
    tableWidth: colW,
    body: astroRows,
  });
}

// ==========================================
// HELPER: Convert Decimal Degree to DD:MM:SS
// ==========================================
function formatDegree(degDec: number | string): string {
  if (degDec === undefined || degDec === null || isNaN(Number(degDec)))
    return "—";
  const num = Number(degDec);
  const d = Math.floor(num);
  const m = Math.floor((num - d) * 60);
  const s = Math.floor(((num - d) * 60 - m) * 60);
  return `${String(d).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
}

// ==========================================
// HELPER: Draw Custom Planet Vector Icons
// ==========================================
function drawPlanetIcon(doc: any, name: string, cx: number, cy: number) {
  const n = name.toUpperCase();
  const c = [220, 85, 80];
  doc.setDrawColor(c[0], c[1], c[2]);
  doc.setFillColor(c[0], c[1], c[2]);
  doc.setLineWidth(0.8);

  if (n.includes("SUN")) {
    doc.circle(cx, cy, 2.5, "S");
    for (let i = 0; i < 8; i++) {
      const ang = (i * 45 * Math.PI) / 180;
      doc.line(
        cx + Math.cos(ang) * 3.5,
        cy + Math.sin(ang) * 3.5,
        cx + Math.cos(ang) * 5.5,
        cy + Math.sin(ang) * 5.5,
      );
    }
  } else if (n.includes("MOON")) {
    doc.circle(cx, cy, 4, "F");
    doc.setFillColor(255, 255, 255);
    doc.circle(cx + 1.5, cy - 1.5, 4, "F");
  } else if (n.includes("MARS")) {
    doc.circle(cx - 1.5, cy + 1.5, 2.5, "S");
    doc.line(cx + 0.5, cy - 0.5, cx + 3.5, cy - 3.5);
    doc.line(cx + 3.5, cy - 3.5, cx + 1, cy - 3.5);
    doc.line(cx + 3.5, cy - 3.5, cx + 3.5, cy - 1);
  } else if (n.includes("MERCURY")) {
    doc.circle(cx, cy, 2, "S");
    doc.line(cx, cy + 2, cx, cy + 5);
    doc.line(cx - 2, cy + 3.5, cx + 2, cy + 3.5);
    doc.ellipse(cx, cy - 2, 2, 1.5, "S");
    doc.setFillColor(255, 255, 255);
    doc.rect(cx - 3, cy - 3.5, 6, 1.5, "F");
  } else if (n.includes("JUPITER")) {
    doc.circle(cx, cy, 3.5, "S");
    doc.line(cx - 3, cy - 1.5, cx + 3, cy - 1.5);
    doc.line(cx - 3, cy + 1.5, cx + 3, cy + 1.5);
  } else if (n.includes("VENUS")) {
    doc.circle(cx, cy - 1.5, 2.5, "S");
    doc.line(cx, cy + 1, cx, cy + 5);
    doc.line(cx - 2, cy + 3, cx + 2, cy + 3);
  } else if (n.includes("SATURN")) {
    doc.circle(cx, cy, 2.5, "F");
    doc.setDrawColor(c[0], c[1], c[2]);
    doc.ellipse(cx, cy, 5.5, 1.5, "S");
  } else if (n.includes("RAHU")) {
    doc.ellipse(cx, cy, 3, 3, "S");
    doc.setFillColor(255, 255, 255);
    doc.rect(cx - 4, cy, 8, 4, "F");
    doc.setFillColor(c[0], c[1], c[2]);
    doc.circle(cx - 2.5, cy, 0.8, "S");
    doc.circle(cx + 2.5, cy, 0.8, "S");
  } else if (n.includes("KETU")) {
    doc.ellipse(cx, cy, 3, 3, "S");
    doc.setFillColor(255, 255, 255);
    doc.rect(cx - 4, cy - 4, 8, 4, "F");
    doc.setFillColor(c[0], c[1], c[2]);
    doc.circle(cx - 2.5, cy, 0.8, "S");
    doc.circle(cx + 2.5, cy, 0.8, "S");
  }
}

// ============================================================
// PAGE 3 — PLANETARY POSITIONS
// ============================================================
export function renderPlanetaryPositionsPage(
  doc: any,
  apiData: Record<string, any>,
  L: any,
) {
  doc.addPage();
  const w = doc.internal.pageSize.getWidth();

  // ✅ USE MINI HELPERS
  addPageBackground(doc);
  let y = addPageHeader(doc, L.planetaryPositions || "Planetary Positions");

  // Extract Planet Data
  const planets = apiData.planets_extended || apiData.planets || [];
  const planetArray: any[] = Array.isArray(planets) ? planets : [];

  // Build Table
  const tableBody: string[][] = [];
  planetArray.forEach((p: any) => {
    const pName = p.name || p.Name || p.planet || "—";
    const retro =
      p.isRetro === true || p.isRetro === "true" || p.is_retro === true
        ? "Yes"
        : "--";
    const sign = p.sign || p.Sign || p.rpiSign || "—";
    const degreeVal = p.normDegree ?? p.fullDegree;
    const degStr = formatDegree(degreeVal);
    const signLord = p.signLord || p.sign_lord || "—";
    const naksh = p.nakshatra || p.Nakshatra || "—";
    const nakshLord = p.nakshatraLord || p.nakshatra_lord || "—";
    const house = p.house || p.House || "—";

    tableBody.push([
      pName,
      retro,
      sign,
      degStr,
      signLord,
      naksh,
      nakshLord,
      String(house),
    ]);
  });

  if (tableBody.length > 0) {
    autoTable(doc, {
      startY: y,
      margin: { left: 14, right: 14 },
      head: [
        [
          L.planet || "Planets",
          "R",
          L.sign || "Sign",
          L.degrees || "Degrees",
          L.signLord || "Sign Lord",
          L.nakshatra || "Nakshatra",
          L.nakshatraLord || "Nakshatra Lord",
          L.house || "House",
        ],
      ],
      body: tableBody,
      theme: "plain",
      headStyles: {
        fillColor: [242, 114, 0],
        textColor: 255,
        fontStyle: "bold",
        fontSize: 7.5,
        halign: "left",
      },
      bodyStyles: { textColor: [80, 80, 80], fontSize: 7.5 },
      styles: { cellPadding: 2.2 },
      alternateRowStyles: { fillColor: [253, 240, 243] },
      columnStyles: { 0: { fontStyle: "bold", textColor: [50, 50, 50] } },
    });
    // @ts-ignore
    y = doc.lastAutoTable.finalY + 12;
  }

  // Planet Grid (3x3)
  const gridPlanets = planetArray.slice(0, 9);
  const margin = 14;
  const gap = 6;
  const colCount = 3;
  const cardW = (w - margin * 2 - gap * (colCount - 1)) / colCount;
  const cardH = 26;

  const getStatus = (pName: string) => {
    const n = pName.toUpperCase();
    if (["SUN", "MARS", "JUPITER"].includes(n))
      return { text: "Unfavorable", color: [220, 100, 100] };
    if (["MOON", "MERCURY"].includes(n))
      return { text: "Neutral", color: [100, 180, 220] };
    if (["VENUS", "SATURN"].includes(n))
      return { text: "Favorable", color: [100, 200, 140] };
    return { text: "--", color: [150, 150, 150] };
  };

  gridPlanets.forEach((p: any, index: number) => {
    const row = Math.floor(index / colCount);
    const col = index % colCount;
    const cx = margin + col * (cardW + gap);
    const cy = y + row * (cardH + gap);

    const pName = p.name || p.Name || p.planet || "—";
    const sign = p.sign || p.Sign || "—";
    const naksh = p.nakshatra || p.Nakshatra || "—";
    const status = getStatus(pName);

    doc.setDrawColor(230, 230, 230);
    doc.setLineWidth(0.3);
    doc.setFillColor(255, 255, 255);
    doc.roundedRect(cx, cy, cardW, cardH, 2, 2, "FD");

    drawPlanetIcon(doc, pName, cx + 10, cy + 9);

    doc.setFont("helvetica", "bold");
    doc.setFontSize(8);
    doc.setTextColor(50, 50, 50);
    doc.text(pName, cx + 20, cy + 6.5);

    doc.setFont("helvetica", "normal");
    doc.setFontSize(6.5);
    doc.setTextColor(120, 120, 120);
    doc.text(sign, cx + 20, cy + 10.5);
    doc.text(naksh, cx + 20, cy + 14);

    doc.setFontSize(7.5);
    doc.setTextColor(status.color[0], status.color[1], status.color[2]);
    doc.text(status.text, cx + cardW / 2, cy + 22, { align: "center" });
  });
}

// ============================================================
// PAGE 4 — HOROSCOPE CHARTS
// ============================================================

export function renderChartsPage(
  doc: jsPDF,
  apiData: Record<string, any>,
  L: Labels,
) {
  // ---------------- DEBUG LOGGER ----------------
  const debugLogs: string[] = [];
  const log = (...args: any[]) => {
    const msg = args
      .map((a) =>
        typeof a === "object" ? JSON.stringify(a, null, 2) : String(a),
      )
      .join(" ");
    console.log(msg);
    debugLogs.push(msg);
  };

  doc.addPage();
  const w = doc.internal.pageSize.getWidth();
  const h = doc.internal.pageSize.getHeight();

  // ---------------- DATA EXTRACTION ----------------
  const planets = apiData?.planets_extended || apiData?.planets;
  const planetArray: any[] = Array.isArray(planets) ? planets : [];

  const ascendant =
    apiData?.astro_details?.ascendant ||
    apiData?.astro_details?.Ascendant ||
    "Aries";

  const ZODIAC_SIGNS = [
    "Aries",
    "Taurus",
    "Gemini",
    "Cancer",
    "Leo",
    "Virgo",
    "Libra",
    "Scorpio",
    "Sagittarius",
    "Capricorn",
    "Aquarius",
    "Pisces",
  ];

  const ascIdx = ZODIAC_SIGNS.findIndex(
    (s) => s.toLowerCase() === String(ascendant).toLowerCase(),
  );

  const lagnaHouse = ascIdx >= 0 ? ascIdx + 1 : 1;

  const PLANET_SYMBOLS: Record<string, string> = {
    SUN: "Su",
    MOON: "Mo",
    MARS: "Ma",
    MERCURY: "Me",
    JUPITER: "Ju",
    VENUS: "Ve",
    SATURN: "Sa",
    RAHU: "Ra",
    KETU: "Ke",
    URANUS: "Ur",
    NEPTUNE: "Ne",
    PLUTO: "Pl",
    ASCENDANT: "As",
  };

  // Computes House 1-12 based on Sign and Ascendant Sign
  // House 1 is always the Ascendant Sign.
  const getHouseNum = (planetSign: number, ascSign: number) => {
    let house = planetSign - ascSign + 1;
    if (house <= 0) house += 12;
    return house;
  };

  /**
   * buildChartData calculates:
   * 1. The signs for each house (1-12)
   * 2. The planets present in each house
   */
  const buildChartData = (signKey: string, chartAscendantSignNum?: number) => {
    // Determine the ascendant sign number for this specific chart
    let ascSignNum = chartAscendantSignNum || ascIdx + 1;

    // Build the signs object: { House1: SignX, House2: SignY, ... }
    const signs: Record<number, number> = {};
    for (let i = 1; i <= 12; i++) {
      let s = ascSignNum + (i - 1);
      if (s > 12) s -= 12;
      signs[i] = s;
    }

    const positions: Record<number, string[]> = {};
    for (let i = 1; i <= 12; i++) positions[i] = [];

    // Only add "As" (Ascendant) marker for the D1 (Lagna) chart.
    if (signKey === "sign" && !chartAscendantSignNum) {
      positions[1].push("As");
    }

    planetArray.forEach((p: any, index: number) => {
      const pName = p.name || p.Name || p.planet || "";
      const signVal = p[signKey] || p.sign || p.Sign || "";

      let planetSignNum = 1;
      const num = Number(signVal);

      if (!isNaN(num) && num >= 1 && num <= 12) {
        planetSignNum = num;
      } else {
        const idx = ZODIAC_SIGNS.findIndex(
          (s) => s.toLowerCase() === String(signVal).toLowerCase(),
        );
        planetSignNum = idx >= 0 ? idx + 1 : 1;
      }

      // Calculate which House (1-12) this planet goes into
      const houseNum = getHouseNum(planetSignNum, ascSignNum);

      const sym = PLANET_SYMBOLS[pName.toUpperCase()] || pName.substring(0, 2);
      const retro = p.isRetro === true || p.isRetro === "true" ? "(R)" : "";

      positions[houseNum].push(sym + retro);
    });

    return { signs, positions };
  };

  // ---------------- LAYOUT CALCULATION ----------------
  let y = 45;
  const chartSize = 85;
  const gap = 15;
  const sideMargin = (w - (chartSize * 2 + gap)) / 2;

  const drawPremiumChartBox = (
    title: string,
    cx: number,
    cy: number,
    data: {
      signs: Record<number, number>;
      positions: Record<number, string[]>;
    },
  ) => {
    doc.text(title, cx + chartSize / 2, cy, { align: "center" });

    // We pass `data.signs` instead of just a string label now
    drawNorthIndianChart(
      doc,
      cx,
      cy + 10,
      chartSize,
      data.positions,
      data.signs,
    );
  };

  // ---------------- DRAW CHARTS ----------------
  const lagnaData = buildChartData("sign");
  drawPremiumChartBox("Lagna Chart (D-1)", sideMargin, y, lagnaData);

  drawPremiumChartBox("Moon Chart", sideMargin + chartSize + gap, y, lagnaData);

  y += chartSize + 30;

  const navData = buildChartData("nakDegree");
  drawPremiumChartBox("Navamsha Chart (D-9)", (w - chartSize) / 2, y, navData);

  // ---------------- LEGEND ----------------
  y += chartSize + 25;

  const legendText =
    "Su = Sun, Mo = Moon, Ma = Mars, Me = Mercury, Ju = Jupiter, Ve = Venus, Sa = Saturn, Ra = Rahu, Ke = Ketu, As = Ascendant, (R) = Retrograde";

  doc.text(legendText, w / 2, y + 7.5, { align: "center" });
}
// ============================================================
// PAGE 5 — VIMSHOTTARI DASHA I
// ============================================================
export function renderDashaPage1(
  doc: any,
  apiData: Record<string, any>,
  subDashaData: Record<string, any>,
  L: any,
) {
  doc.addPage();
  const w = doc.internal.pageSize.getWidth();
  const h = doc.internal.pageSize.getHeight();

  // ✅ USE MINI HELPERS
  addPageBackground(doc);
  const titleText = L.vimshottariDasha1 || "Vimshottari Dasha - I";
  addPageHeader(doc, titleText);

  const titleBlue: Color3 = [30, 50, 100];
  const rowPink: Color3 = [253, 240, 243];
  const orange: Color3 = [242, 114, 0];

  const majorDasha = apiData?.major_vdasha;
  const dashaList = Array.isArray(majorDasha) ? majorDasha : [];

  const planetsToRender =
    typeof DASHA_ORDER_PAGE5 !== "undefined"
      ? DASHA_ORDER_PAGE5
      : ["Mars", "Rahu", "Jupiter", "Saturn", "Mercury", "Ketu"];

  const margin = 14;
  const gap = 12;
  const colWidth = (w - margin * 2 - gap * 2) / 3;
  const cols = [margin, margin + colWidth + gap, margin + (colWidth + gap) * 2];
  const colY = [35, 35, 35];

  planetsToRender.forEach((planet, idx) => {
    const col = idx % 3;
    const colX = cols[col];
    const centerColX = colX + colWidth / 2;
    let y = colY[col];

    // Page Break Logic
    if (y > h - 45) {
      doc.addPage();
      addPageBackground(doc);
      addPageHeader(doc, titleText + " (contd.)");
      colY.fill(35);
      y = 35;
    }

    const dasha = dashaList.find(
      (d: any) =>
        (d.planet || d.Planet || d.name || "").toLowerCase() ===
        planet.toLowerCase(),
    );
    const startDate = dasha ? dasha.start || dasha.startDate || "" : "";
    const endDate = dasha ? dasha.end || dasha.endDate || "" : "";

    // Planet Header
    doc.setFont("helvetica", "bold");
    doc.setFontSize(10);
    doc.setTextColor(titleBlue[0], titleBlue[1], titleBlue[2]);
    doc.text(planet, centerColX, y + 10, { align: "center" });

    if (startDate || endDate) {
      doc.setFont("helvetica", "normal");
      doc.setFontSize(7);
      doc.setTextColor(100, 100, 100);
      if (startDate)
        doc.text(startDate.replace("  ", " "), centerColX, y + 14, {
          align: "center",
        });
      if (endDate)
        doc.text(endDate.replace("  ", " "), centerColX, y + 17.5, {
          align: "center",
        });
    }

    y += 21;
    doc.setDrawColor(200, 200, 200);
    doc.setLineWidth(0.3);
    doc.line(colX + 5, y, colX + colWidth - 5, y);
    y += 4;

    // Antardasha Table
    const subData = subDashaData?.[planet];
    const subList = Array.isArray(subData) ? subData : [];

    if (subList.length > 0) {
      const tableBody = subList.map((s: any) => [
        s.planet || s.Planet || s.name || "—",
        (s.end || s.endDate || s.end_date || "—").replace("  ", " "),
      ]);

      autoTable(doc, {
        startY: y,
        margin: { left: colX, right: 14 },
        tableWidth: colWidth,
        body: tableBody,
        theme: "plain",
        bodyStyles: { fontSize: 7.5, cellPadding: 2 },
        alternateRowStyles: { fillColor: rowPink },
        columnStyles: {
          0: { fontStyle: "bold", textColor: titleBlue, halign: "left" },
          1: { textColor: [100, 100, 100], halign: "right" },
        },
      });

      // @ts-ignore
      colY[col] = doc.lastAutoTable?.finalY + 15;
    } else {
      doc.setFont("helvetica", "normal");
      doc.setFontSize(7);
      doc.setTextColor(150, 150, 150);
      doc.text("(data unavailable)", centerColX, y + 5, { align: "center" });
      colY[col] = y + 15;
    }
  });
}

// ============================================================
// PAGE 6 — VIMSHOTTARI DASHA II
// ============================================================
export function renderDashaPage2(
  doc: jsPDF,
  apiData: Record<string, any>,
  subDashaData: Record<string, any>,
  L: any,
  DASHA_ORDER: string[] = ["Venus", "Sun", "Moon", "Mars", "Rahu", "Jupiter"],
) {
  try {
    const w = doc.internal.pageSize.getWidth();
    const h = doc.internal.pageSize.getHeight();

    doc.addPage();

    // ✅ USE MINI HELPERS
    addPageBackground(doc);
    const title = L.vimshottariDasha2 || "Vimshottari Dasha - II";
    addPageHeader(doc, title);

    const majorDasha = apiData?.major_vdasha;
    const dashaList = Array.isArray(majorDasha) ? majorDasha : [];

    const margin = 15;
    const gap = 10;
    const colWidth = (w - margin * 2 - gap * 2) / 3;
    const cols = [
      margin,
      margin + colWidth + gap,
      margin + (colWidth + gap) * 2,
    ];
    let colY = [38, 38, 38];

    DASHA_ORDER.forEach((planet, idx) => {
      const col = idx % 3;
      const colX = cols[col];
      let y = colY[col];

      if (y > h - 60) {
        doc.addPage();
        addPageBackground(doc);
        addPageHeader(doc, title + " (contd.)");
        colY.fill(38);
        y = 38;
      }

      const dasha = dashaList.find(
        (d: any) =>
          (d.planet || d.Planet || d.name || "").toLowerCase() ===
          planet.toLowerCase(),
      );

      const startDate = dasha ? dasha.start || dasha.startDate || "" : "";
      const endDate = dasha ? dasha.end || dasha.endDate || "" : "";

      doc.setFontSize(10);
      doc.setTextColor(34, 46, 93);
      doc.setFont("helvetica", "bold");
      doc.text(planet.toUpperCase(), colX + colWidth / 2, y, {
        align: "center",
      });
      y += 4;

      doc.setDrawColor(200, 200, 200);
      doc.setLineWidth(0.3);
      doc.line(colX, y, colX + colWidth, y);
      y += 5;

      doc.setFontSize(8);
      doc.setTextColor(100, 100, 100);
      doc.setFont("helvetica", "normal");
      doc.text(`${startDate}\n${endDate}`, colX + colWidth / 2, y, {
        align: "center",
        lineHeightFactor: 1.5,
      });
      y += 8;

      doc.line(colX, y, colX + colWidth, y);
      y += 3;

      const subData = subDashaData?.[planet];
      const subList = Array.isArray(subData) ? subData : [];

      if (subList.length > 0) {
        autoTable(doc, {
          startY: y,
          margin: { left: colX },
          tableWidth: colWidth,
          showHead: "never",
          body: subList.map((s: any) => [
            s.planet || s.Planet || s.name || "—",
            s.end || s.endDate || s.end_date || "—",
          ]),
          theme: "plain",
          styles: {
            cellPadding: { top: 2, bottom: 2, left: 1, right: 1 },
            fontSize: 8,
          },
          columnStyles: {
            0: { fontStyle: "bold", textColor: [106, 26, 26], halign: "left" },
            1: { halign: "right", textColor: [80, 80, 80] },
          },
          alternateRowStyles: { fillColor: [252, 238, 238] },
        });
        // @ts-ignore
        colY[col] = doc.lastAutoTable.finalY + 12;
      } else {
        colY[col] = y + 10;
      }
    });

    const finalY = Math.max(...colY) + 10;
    if (finalY < h - 20) {
      doc.setFontSize(9);
      doc.setTextColor(34, 46, 93);
      doc.setFont("helvetica", "bold");
      doc.text(
        "* NOTE : All the dates are indicating dasha end date.",
        15,
        finalY,
      );
    }
  } catch (error) {
    console.error("Error rendering Dasha Page 2: ", error);
  }
}

// ============================================================
// PAGE 7 — VIMSHOTTARI DASHA III + CURRENT DASHA
// ============================================================
export function renderDashaPage3(
  doc: jsPDF,
  apiData: Record<string, any>,
  subDashaData: Record<string, any>,
  L: any,
  DASHA_ORDER: string[] = ["Saturn", "Mercury", "Ketu"],
) {
  try {
    const w = doc.internal.pageSize.getWidth();
    const h = doc.internal.pageSize.getHeight();

    doc.addPage();

    // ✅ USE MINI HELPERS
    addPageBackground(doc);
    const title = L.vimshottariDasha3 || "Vimshottari Dasha - III";
    addPageHeader(doc, title);

    const majorDasha = apiData?.major_vdasha;
    const dashaList = Array.isArray(majorDasha) ? majorDasha : [];

    const margin = 15;
    const gap = 10;
    const colWidth = (w - margin * 2 - gap * 2) / 3;
    const cols = [
      margin,
      margin + colWidth + gap,
      margin + (colWidth + gap) * 2,
    ];
    let colY = [38, 38, 38];

    DASHA_ORDER.forEach((planet, idx) => {
      const col = idx % 3;
      const colX = cols[col];
      let y = colY[col];

      if (y > h - 60) {
        doc.addPage();
        addPageBackground(doc);
        addPageHeader(doc, title + " (contd.)");
        colY.fill(38);
        y = 38;
      }

      const dasha = dashaList.find(
        (d: any) =>
          (d.planet || d.Planet || d.name || "").toLowerCase() ===
          planet.toLowerCase(),
      );

      const startDate = dasha ? dasha.start || dasha.startDate || "" : "";
      const endDate = dasha ? dasha.end || dasha.endDate || "" : "";

      doc.setFontSize(10);
      doc.setTextColor(34, 46, 93);
      doc.setFont("helvetica", "bold");
      doc.text(planet.toUpperCase(), colX + colWidth / 2, y, {
        align: "center",
      });
      y += 4;

      doc.setDrawColor(200, 200, 200);
      doc.setLineWidth(0.3);
      doc.line(colX, y, colX + colWidth, y);
      y += 5;

      doc.setFontSize(8);
      doc.setTextColor(100, 100, 100);
      doc.setFont("helvetica", "normal");
      doc.text(`${startDate}\n${endDate}`, colX + colWidth / 2, y, {
        align: "center",
        lineHeightFactor: 1.5,
      });
      y += 8;

      doc.line(colX, y, colX + colWidth, y);
      y += 3;

      const subData = subDashaData?.[planet];
      const subList = Array.isArray(subData) ? subData : [];

      if (subList.length > 0) {
        autoTable(doc, {
          startY: y,
          margin: { left: colX },
          tableWidth: colWidth,
          showHead: "never",
          body: subList.map((s: any) => [
            s.planet || s.Planet || s.name || "—",
            s.end || s.endDate || s.end_date || "—",
          ]),
          theme: "plain",
          styles: {
            cellPadding: { top: 2, bottom: 2, left: 1, right: 1 },
            fontSize: 8,
          },
          columnStyles: {
            0: { fontStyle: "bold", textColor: [106, 26, 26], halign: "left" },
            1: { halign: "right", textColor: [80, 80, 80] },
          },
          alternateRowStyles: { fillColor: [252, 238, 238] },
        });
        // @ts-ignore
        colY[col] = doc.lastAutoTable.finalY + 12;
      } else {
        colY[col] = y + 10;
      }
    });

    // Current Dasha Section
    let finalY = Math.max(...colY) + 10;

    if (finalY > h - 70) {
      doc.addPage();
      addPageBackground(doc);
      finalY = 30;
    }

    // ✅ USE MINI SECTION TITLE
    finalY = addSectionTitle(
      doc,
      L.currentDasha || "Current Undergoing Dasha",
      finalY,
    );

    const currentDasha = apiData?.current_vdasha;
    if (currentDasha) {
      const rows: string[][] = [];

      const addRow = (label: string, obj: any) => {
        if (!obj) return;
        const planet = obj.planet || obj.Planet || "—";
        const start = obj.start || obj.startDate || "—";
        const end = obj.end || obj.endDate || "—";
        rows.push([label, planet, start, end]);
      };

      addRow(
        L.mahadasha || "MAHADASHA",
        currentDasha.major || currentDasha.major_dasha,
      );
      addRow(
        L.antardasha || "ANTARDASHA",
        currentDasha.minor || currentDasha.sub_dasha,
      );
      addRow(
        "PRTYANTAR DASHA",
        currentDasha.sub_minor || currentDasha.sub_sub_dasha,
      );
      addRow(
        "SOOKSHM DASHA",
        currentDasha.sub_sub_minor || currentDasha.sub_sub_sub_dasha,
      );

      if (rows.length > 0) {
        autoTable(doc, {
          startY: finalY,
          margin: { left: 15, right: 15 },
          head: [
            [
              L.dashaName || "Dasha Name",
              L.planet || "Planets",
              L.startDate || "Start Date",
              L.endDate || "End Date",
            ],
          ],
          body: rows,
          theme: "plain",
          headStyles: {
            fillColor: [239, 126, 34],
            textColor: 255,
            fontStyle: "bold",
            halign: "left",
          },
          styles: { cellPadding: 4, fontSize: 9, textColor: [34, 46, 93] },
          alternateRowStyles: { fillColor: [252, 238, 238] },
        });
        // @ts-ignore
        finalY = doc.lastAutoTable.finalY + 12;
      }
    }

    if (finalY < h - 20) {
      doc.setFontSize(9);
      doc.setTextColor(34, 46, 93);
      doc.setFont("helvetica", "bold");
      doc.text(
        "* NOTE : All the dates are indicating dasha end date.",
        15,
        finalY,
      );
    }
  } catch (error) {
    console.error("Error rendering Dasha Page 3: ", error);
  }
}

// ============================================================
// PAGE 8 — ASCENDANT REPORT
// ============================================================
export function renderAscendantPage(
  doc: jsPDF,
  apiData: Record<string, any>,
  L: any,
  ZODIAC: string[] = [
    "Aries",
    "Taurus",
    "Gemini",
    "Cancer",
    "Leo",
    "Virgo",
    "Libra",
    "Scorpio",
    "Sagittarius",
    "Capricorn",
    "Aquarius",
    "Pisces",
  ],
  LORDS: string[] = [
    "Mars",
    "Venus",
    "Mercury",
    "Moon",
    "Sun",
    "Mercury",
    "Venus",
    "Mars",
    "Jupiter",
    "Saturn",
    "Saturn",
    "Jupiter",
  ],
  ASC_DATA: Record<string, any> = {},
): string {
  try {
    const w = doc.internal.pageSize.getWidth();
    const h = doc.internal.pageSize.getHeight();

    doc.addPage();

    // ✅ USE MINI HELPERS
    addPageBackground(doc);
    const title = L.ascendantReport || "Ascendant Report";
    let currentY = addPageHeader(doc, title);

    const ascName =
      apiData?.astro_details?.ascendant ||
      apiData?.astro_details?.Ascendant ||
      "Aries";
    const meta = ASC_DATA[ascName] || ASC_DATA["Aries"] || {};
    const signIndex = ZODIAC.indexOf(ascName);
    const lord = LORDS[signIndex] || "—";

    // Ascendant Sign Image — use real image from basic_pdf_images
    const ascImgFile =
      getLocalImageBase64(`${ascName}.jpg`) ||
      getLocalImageBase64("Ascendant_Report.jpg");

    if (ascImgFile) {
      const imgR = 20;
      doc.addImage(
        ascImgFile,
        ascImgFile.startsWith("data:image/png") ? "PNG" : "JPEG",
        45 - imgR,
        currentY + 2,
        imgR * 2,
        imgR * 2,
      );
    } else {
      // Fallback: simple circle placeholder
      doc.setDrawColor(220, 220, 220);
      doc.setLineWidth(0.5);
      doc.circle(45, currentY + 20, 20, "S");
      doc.setFontSize(9);
      doc.setTextColor(150, 150, 150);
      doc.setFont("helvetica", "normal");
      doc.text("(Image)", 45, currentY + 22, { align: "center" });
    }

    // Attributes Table
    const tableStartX = w * 0.45;
    const tableWidth = w * 0.45;

    doc.setFontSize(11);
    doc.setTextColor(34, 46, 93);
    doc.setFont("helvetica", "bold");
    doc.text(`${title} - ${ascName}`, tableStartX + 5, currentY + 5);

    const charStr = [meta?.element, meta?.nature, meta?.direction]
      .filter(Boolean)
      .join(", ");

    const attrRows = [
      [L.lord || "Lord", lord],
      [L.symbol || "Symbol", meta?.symbol || "—"],
      [L.characteristics || "Characteristics", charStr || "—"],
      [L.luckyGem || "Lucky gems", meta?.luckyGem || "—"],
      [L.dayOfFast || "Day of fast", meta?.dayOfFast || "—"],
    ];

    autoTable(doc, {
      startY: currentY + 10,
      margin: { left: tableStartX },
      tableWidth: tableWidth,
      body: attrRows,
      theme: "plain",
      styles: {
        cellPadding: { top: 3.5, bottom: 3.5, left: 5, right: 5 },
        fontSize: 9.5,
      },
      columnStyles: {
        0: { cellWidth: 35, textColor: [34, 46, 93], fontStyle: "normal" },
        1: { textColor: [100, 100, 100], fontStyle: "normal" },
      },
      alternateRowStyles: { fillColor: [253, 240, 240] },
    });

    // @ts-ignore
    currentY = Math.max(currentY + 60, doc.lastAutoTable.finalY + 20);

    // Shloka
    const shlokaText =
      meta?.shloka ||
      "देहं रूपं च ज्ञानं च वर्णं चैव बलाबलम् |\nसुखं दुःखं स्वभावञ्च लग्नभावात्रिरीक्षयेत ||";

    if (shlokaText && shlokaText !== "—") {
      const shlokaLines = doc.splitTextToSize(shlokaText, w - 40);
      doc.setFontSize(15);
      doc.setTextColor(218, 83, 44);
      doc.setFont("helvetica", "bold");
      doc.text(shlokaLines, w / 2, currentY, {
        align: "center",
        lineHeightFactor: 1.5,
      });
      currentY += shlokaLines.length * 8 + 15;
    }

    // Personality Paragraphs
    let allParas: string[] = [];
    const apiReport =
      apiData?.general_ascendant_report?.asc_report?.report ||
      apiData?.general_ascendant_report?.report;

    if (apiReport && typeof apiReport === "string") {
      const sentences = apiReport
        .split(". ")
        .filter((s) => s.trim().length > 0);
      let p1 = sentences.slice(0, 3).join(". ") + ".";
      let p2 = sentences.slice(3, 5).join(". ") + ".";
      let p3 =
        sentences.slice(5).join(". ") + (sentences.length > 5 ? "." : "");

      if (p1.length > 2) allParas.push(p1);
      if (p2.length > 2) allParas.push(p2);
      if (p3.length > 2) allParas.push(p3);
    } else if (meta?.personality) {
      allParas = [...meta.personality];
    }

    allParas.forEach((para, index) => {
      if (!para || para.trim() === "") return;

      const isQuote = index === 1;
      const textWidth = isQuote ? w - 55 : w - 30;
      const lines = doc.splitTextToSize(para, textWidth);
      const blockH = lines.length * 6;

      if (currentY + blockH > h - 20) {
        doc.addPage();
        addPageBackground(doc);
        addPageHeader(doc, title + " (contd.)");
        currentY = 45;
      }

      if (isQuote) {
        const quoteBoxY = currentY;
        doc.setDrawColor(239, 126, 34);
        doc.setLineWidth(1.5);
        doc.line(20, quoteBoxY, 20, quoteBoxY + blockH);

        doc.setTextColor(239, 126, 34);
        doc.setFontSize(26);
        doc.setFont("helvetica", "bold");
        doc.text('"', 25, quoteBoxY + 8);

        doc.setFontSize(10.5);
        doc.setFont("helvetica", "italic");
        doc.text(lines, 34, quoteBoxY + 6, { lineHeightFactor: 1.5 });

        currentY += blockH + 15;
      } else {
        doc.setTextColor(80, 80, 80);
        doc.setFontSize(9.5);
        doc.setFont("helvetica", "normal");
        doc.text(lines, 15, currentY + 4, { lineHeightFactor: 1.6 });
        currentY += blockH + 10;
      }
    });

    return ascName;
  } catch (error) {
    console.error("Error rendering Ascendant Page: ", error);
    return "Aries";
  }
}

// ============================================================
// PAGE 9 — ASCENDANT ANALYSIS CONTINUED
// ============================================================
export function renderAscendantAnalysisPage(
  doc: jsPDF,
  ascName: string,
  L: any,
  ZODIAC: string[] = [
    "Aries",
    "Taurus",
    "Gemini",
    "Cancer",
    "Leo",
    "Virgo",
    "Libra",
    "Scorpio",
    "Sagittarius",
    "Capricorn",
    "Aquarius",
    "Pisces",
  ],
  LORDS: string[] = [
    "Mars",
    "Venus",
    "Mercury",
    "Moon",
    "Sun",
    "Mercury",
    "Venus",
    "Mars",
    "Jupiter",
    "Saturn",
    "Saturn",
    "Jupiter",
  ],
  ASC_DATA: Record<string, any> = {},
) {
  try {
    const w = doc.internal.pageSize.getWidth();
    const h = doc.internal.pageSize.getHeight();

    doc.addPage();

    // ✅ USE MINI HELPERS
    addPageBackground(doc);

    const meta = ASC_DATA[ascName] || {};
    const signIndex = ZODIAC.indexOf(ascName);
    const lord = LORDS[signIndex] || "—";

    let currentY = 25;

    const checkPageBreak = (neededHeight: number) => {
      if (currentY + neededHeight > h - 20) {
        doc.addPage();
        addPageBackground(doc);
        currentY = 25;
      }
    };

    // Top Sentence
    const impText = `${lord} rules ${ascName} so ${lord} will be important in your chart.`;
    doc.setFont("helvetica", "normal");
    doc.setFontSize(9.5);
    doc.setTextColor(80, 80, 80);
    doc.text(impText, w / 2, currentY, { align: "center" });
    currentY += 12;

    // Spiritual Lesson Box
    const spiritText =
      meta.spiritualLesson ||
      "Control (learn to control and not scatter energies and to prioritize).";
    const spiritLines = doc.splitTextToSize(spiritText, w - 40);
    const boxPadding = 12;
    const boxHeight = boxPadding * 2 + 32 + spiritLines.length * 6;

    checkPageBreak(boxHeight);

    doc.setFillColor(242, 242, 242);
    doc.rect(15, currentY, w - 30, boxHeight, "F");

    let innerY = currentY + boxPadding + 6;

    doc.setFontSize(16);
    doc.setTextColor(242, 185, 33);
    doc.setFont("helvetica", "bold");
    doc.text("OM", w / 2, innerY, { align: "center" });
    innerY += 8;

    // ✅ USE MINI SECTION TITLE STYLE
    doc.setFontSize(15);
    doc.setTextColor(34, 46, 93);
    doc.setFont("helvetica", "bold");
    doc.text(L.spiritualLesson || "Spiritual lesson to learn", w / 2, innerY, {
      align: "center",
    });
    innerY += 5;
    drawDecoLine(doc, w / 2, innerY);
    innerY += 9;

    doc.setFontSize(13);
    doc.setTextColor(60, 60, 60);
    doc.setFont("helvetica", "normal");
    doc.text(spiritLines, w / 2, innerY, {
      align: "center",
      lineHeightFactor: 1.5,
    });

    currentY += boxHeight + 15;

    // Traits Pills Renderer
    const renderTraitsPills = (traits: string[], colors: number[][]) => {
      const maxWidth = w - 40;
      const paddingX = 7;
      const pillHeight = 7.5;
      const gapX = 4;
      const gapY = 8;

      doc.setFontSize(8.5);
      doc.setFont("helvetica", "normal");

      const pillData = traits.map((trait, index) => ({
        text: trait,
        width: doc.getTextWidth(trait) + paddingX * 2,
        color: colors[index % colors.length],
      }));

      const rows: any[][] = [];
      let currentRow: any[] = [];
      let currentWidth = 0;

      pillData.forEach((pill) => {
        if (
          currentWidth + pill.width + (currentRow.length > 0 ? gapX : 0) >
          maxWidth
        ) {
          rows.push(currentRow);
          currentRow = [pill];
          currentWidth = pill.width;
        } else {
          currentRow.push(pill);
          currentWidth += pill.width + (currentRow.length > 1 ? gapX : 0);
        }
      });
      if (currentRow.length > 0) rows.push(currentRow);

      rows.forEach((row) => {
        checkPageBreak(pillHeight + gapY);
        const rowWidth =
          row.reduce((sum, p) => sum + p.width, 0) + (row.length - 1) * gapX;
        let startX = (w - rowWidth) / 2;

        row.forEach((pill) => {
          doc.setFillColor(pill.color[0], pill.color[1], pill.color[2]);
          doc.roundedRect(
            startX,
            currentY,
            pill.width,
            pillHeight,
            3.5,
            3.5,
            "F",
          );
          doc.setTextColor(255, 255, 255);
          doc.text(pill.text, startX + pill.width / 2, currentY + 5.2, {
            align: "center",
          });
          startX += pill.width + gapX;
        });
        currentY += pillHeight + gapY;
      });
    };

    // Positive Traits
    const posTraits =
      meta.positiveTraits?.length > 0
        ? meta.positiveTraits
        : ["Intellectual", "Planner", "Versatile Adaptable", "Logical"];

    checkPageBreak(30);
    currentY = addSectionTitle(
      doc,
      L.positiveTraits || "Positive Traits",
      currentY,
    );

    const positiveColors = [
      [52, 142, 67],
      [81, 196, 96],
      [0, 168, 168],
      [42, 188, 214],
    ];
    renderTraitsPills(posTraits, positiveColors);
    currentY += 10;

    // Negative Traits
    const negTraits =
      meta.negativeTraits?.length > 0
        ? meta.negativeTraits
        : ["Wavering Mind", "Restless", "Gossipi", "Manipulative"];

    checkPageBreak(30);
    currentY = addSectionTitle(
      doc,
      L.negativeTraits || "Negative Traits",
      currentY,
    );

    const negativeColors = [
      [239, 126, 34],
      [255, 87, 51],
      [255, 140, 0],
      [247, 191, 14],
    ];
    renderTraitsPills(negTraits, negativeColors);
  } catch (error) {
    console.error("Error rendering Ascendant Analysis Page: ", error);
  }
}

// ============================================================
// PAGE 10 — DISCLAIMER / BACK COVER
// ============================================================
export function renderDisclaimerPage(doc: jsPDF, L: any) {
  try {
    const w = doc.internal.pageSize.getWidth();
    const h = doc.internal.pageSize.getHeight();

    doc.addPage();

    // Unique back cover - custom background
    doc.setFillColor(248, 248, 248);
    doc.rect(0, 0, w, h, "F");

    const centerY = h / 2 - 20;
    const cx = w / 2;

    // Decorative Lines
    drawDecoLine(doc, cx, centerY - 16);

    // Logo Text
    doc.setFont("helvetica", "bold");
    doc.setFontSize(28);

    const text1 = "astro";
    const text2 = "web";
    const w1 = doc.getTextWidth(text1);
    const w2 = doc.getTextWidth(text2);
    const totalW = w1 + w2;
    const startX = cx - totalW / 2;

    doc.setFillColor(233, 77, 101);
    doc.circle(startX + 1.8, centerY - 9, 0.8, "F");
    doc.circle(startX + 5.2, centerY - 9, 0.8, "F");

    doc.setTextColor(233, 77, 101);
    doc.text(text1, startX, centerY);

    doc.setTextColor(92, 136, 199);
    doc.text(text2, startX + w1, centerY);

    drawDecoLine(doc, cx, centerY + 8);

    // Orange Footer
    const footerHeight = h * 0.18;
    doc.setFillColor(239, 126, 34);
    doc.rect(0, h - footerHeight, w, footerHeight, "F");
  } catch (error) {
    console.error("Error rendering Disclaimer Page: ", error);
  }
}
